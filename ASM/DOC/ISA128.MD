# Aurora128 Instruction Set Reference
**Revision:** 1.0.2

**Architecture:** 128-bit RISC (Aurora Extended)

## 1. Register File

Aurora128 features thirty-two 128-bit general-purpose registers.

- **R0:** Hardwired to Zero.
- **R1-R29:** General Purpose / Scratch.
- **R30:** Exception Link Register (ELR) - Stores return address on interrupt/syscall.
- **R31:** Link Register (LR) - Stores return address for standard `CALL` instructions.
- **PC:** 128-bit Program Counter.

## 2. Instruction Formats

All instructions are 32-bit fixed width, regardless of the 128-bit data path.

| Type | Format     | Bits       | Bits | Bits | Bits | Bits [10:0]               |
|------|------------|-----------|------|------|------|---------------------------|
| R    | Register   | Opcode    | Rd   | Rs1  | Rs2  | Unused                    |
| I    | Immediate  | Opcode    | Rd   | Rs1  | Immediate (16-bit signed) | —                         |
| J    | Jump       | Opcode    | Address (26-bit)    | —    | —    |    —       |

## 3. Core Instruction Set

### Arithmetic & Logic

- `ADD Rd, Rs1, Rs2` : `Rd = Rs1 + Rs2` (128-bit carry propagation).
- `SUB Rd, Rs1, Rs2` : `Rd = Rs1 - Rs2`.
- `ADDI Rd, Rs1, Imm` : `Rd = Rs1 + ZeroExtend(Imm)`.
- `CLZ Rd, Rs1` : Count Leading Zeros. Returns the number of leading zeros in `Rs1` (0-128) into `Rd`.
- `MOV128 Rd, Rs1` : Copies full 128-bit contents of `Rs1` to `Rd`.

### Barrel Shifter

- `SLL Rd, Rs1, Rs2` : Logical Shift Left `Rd` by the value in `Rs2.Low` (Masked to 7-bits).
- `SRL Rd, Rs1, Rs2` : Logical Shift Right `Rd` by the value in `Rs2.Low`. 

### Memory Access

- `LOAD Rd, Rs1, Imm` : Load 128-bits from `Memory[Rs1 + Imm]` into `Rd`.
- `STORE Rd, Rs1, Imm` : Store 128-bits from `Rd` to `Memory[Rs1 + Imm]`.

### Atomic & Synchronization

- `CAS Rd, Rs1, Rs2` : Compare and Swap.
	- Atomically compares `Memory[Rs1]` with `Rs2`.
	- If equal, `Memory[Rs1] = Rd`
	- Always returns the original value of `Memory[Rs1]` into `Rd`.

- `AMOADD Rd, Rs1, Rs2` : Atomic Memory Add.
	- Atomically: `temp = Memory[Rs1]`, `Memory[Rs1] += Rs2`
	- Returns `temp` (original value) into `Rd`.

### Control Flow

- `JMP addr` : Unconditional jump to 26-bit absolute address.
- `BEQ Rd, Rs1, Imm` : Branch if `Rd == Rs1` to `PC + (Imm << 2)`.
- `CALL addr` : `R31 = PC + 4`, Jump to `addr`.
- `RET` : Jump to `R31`.
- `RETI` : Return from Interrupt. Jump to `R30`.

### System

- `SYSCALL` : Triggers a software interrupt (Vector 2). Swaps to Kernel Mode.
- `HALT` : Suspends processor execution.

## 4. Interrupt Vectors

The vector table starts at `0xF000` in the 1MB physical map (expandable).

| Vector | Name     | Description                       |
|--------|----------|-----------------------------------|
| 0      | INT_TIMER | Hardware Timer Tick               |
| 1      | INT_KBD   | Keyboard Input                    |
| 2      | INT_SYS   | Software Syscall                  |
| 3      | INT_MM    | Memory Management / Page Fault    |
| 4      | INT_DISK  | Disk Management                   |
| 5      | INT_PTR   | Mouse Input                       |
| 15     | INT_INV   | Invalid Opcode / Exception        |
